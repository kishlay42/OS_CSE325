Program1:Towritesomedataonthestandardoutputdevice(bydefault–monitor)
//Nametheprogramfileas“write.c”
#include<unistd.h>
intmain()
{
write(1,"hello\n",6);//1isthefiledescriptor,"hello\n"isthedata,6isthecountofcharacters
indata
}
Program2
#include<stdio.h
#include<unistd.h>
intmain()
{
intcount;
count=write(1,"hello\n",6);
printf("Totalbyteswritten:%d\n",count);
}
Program3:
#include<unistd.h>
intmain()
{
write(1,"hello\n",60);//thebytestobeprinted(thirdparameter)aremorethanthedata
specifiedin2ndparameter
}
Program4:
#include<unistd.h>
intmain()
{
write(1,"hello\n",3);//thebytestobeprinted(thirdparameter)arelessthanthedataspecified
in2ndparameter
}
Program5:
#include<unistd.h>
#include<stdio.h>
intmain()
{
intcount;
count=write(3,"hello\n",6);//thefiledescriptorisnotoneofthepre-specifiedonesi.e.,0,1or
2
printf("Totalbyteswritten:%d\n",count);
}
Program6:Toreaddatafromthestandardinputdeviceandwriteitonthescreen
//read.c
#include<unistd.h>
intmain()
{
charbuff[20];
read(0,buff,10);//read10bytesfromstandardinputdevice(keyboard),storeinbuffer(buff)
write(1,buff,10);//print10bytesfromthebufferonthescreen
}
Program7:Toreaddatafromthestandardinputdeviceandwriteitonthescreen
//read.c
#include<unistd.h>
intmain()
{
intnread;
charbuff[20];
nread=read(0,buff,10);//read10bytesfrom standardinputdevice(keyboard),storeinbuffer
(buff)
write(1,buff,nread);//print10bytesfromthebufferonthescreen
}
Program 1:Writeaprogram usingopen()system calltoreadthefirst10charactersofan
existingfile“test.txt”andprintthemonscreen.
//open.c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
intmain()
{
intn,fd;
charbuff[50];
fd=open("test.txt",O_RDONLY);//openstest.txtinreadmodeandthefiledescriptorissaved
inintegerfd.
printf("Thefiledescriptorofthefileis:%d\n,fd);//thevalueofthefiledescriptorisprinted.
n=read(fd,buff,10);//read10charactersfrom thefilepointedtobyfiledescriptorfdandsave
theminbuffer(buff)
write(1,buff,n);//writeonthescreenfromthebuffer
}
Program2:Toread10charactersfrom file“test.txt”andwritethem intonon-existingfile
“towrite.txt”
//open2.c
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
intmain()
{
intn,fd,fd1;
charbuff[50];
fd=open("test.txt",O_RDONLY);
n=read(fd,buff,10);
fd1=open("towrite.txt",O_WRONLY|O_CREAT,0642);//use the pipe symbol(|)to separate
O_WRONLYandO_CREAT
write(fd1,buff,n);
}
Program1:Programusinglseek()systemcallthatreads10charactersfromfile“seeking”and
printonscreen.Againread10charactersandwriteonscreen.
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h
#include<sys/stat.h>
#intmain()
{
intn,f;
charbuff[10];
f=open("seeking",O_RDWR);
read(f,buff,10);
write(1,buff,10);
read(f,buff,10);
write(1,buff,10);
}
Program2:Programusinglseek()systemcallthatreads10charactersfromfile“seeking”and
printonscreen.Skipnext5charactersandagainread10charactersandwriteonscreen.
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h
#include<sys/stat.h>
intmain()
{
intn,f;
charbuff[10];
f=open("seeking",O_RDWR);
read(f,buff,10);
write(1,buff,10);
lseek(f,5,SEEK_CUR);//skips5charactersfromthecurrentposition
read(f,buff,10);
write(1,buff,10);
}
Program3:Writeaprogramtoprint10charactersstartingfromthe10thcharacterfromafile
“seeking”.
//LetthecontentsofthefileF1be“1234567890abcdefghijxxxxxxxx”.Thismeanswewant
theoutputtobe“abcdefghij”.
//Note:thefirstcharacter‘1’isat0thposition
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h
#include<sys/stat.h>
#include<stdio.h>
intmain()
{
intn,f,f1;
charbuff[10];
f=open("seeking",O_RDWR);
f1=lseek(f,10,SEEK_SET);
printf("Pointerisat%dposition\n",f1);
read(f,buff,10);
write(1,buff,10);
}
Program1:Programfordup()systemcallinCtoduplicateafiledescriptor.
//dup.c
#include<unistd.h>
#include<stdio.h>
3include<fcntl.h>
intmain()
{
intold_fd,new_fd;
old_fd=open("test.txt",O_RDWR);
printf("Filedescriptoris%d\n",old_fd);
new_fd=dup(old_fd);
printf("Newfiledescriptoris%d\n",new_fd);
}
Program2:Programtousedup2()systemcallinlinuxtoduplicateafiledescriptor.
//dup2.c
#include<unistd.h>
#include<stdio.h>
3include<fcntl.h>
intmain()
{
intold_fd,new_fd;
old_fd=open("test.txt",O_RDWR);
printf("Filedescriptoris%d\n",old_fd);
new_fd=dup2(old_fd,7);
printf("Newfiledescriptoris%d\n",new_fd);
}
Program3:Programtoshowthatbothfiledescriptorpointtothesamefileandsamepointer
positionismaintained
//createafiletest.txtwiththecontent"1234567890abcdefghij54321"
#include<unistd.h>
#include<stdio.h>
#include<fcntl.h>
intmain()
{
intold_fd,new_fd;
charbuff[10];
old_fd=open("test.txt",O_RDWR);
read(old_fd,buff,10);//readfirst10charactersusingoldfiledescriptor
write(1,buff,10);//printsthemonscreen
new_fd=dup(old_fd);//duplicatesfiledescriptor
read(old_fd,buff,10);//thisreadwillreadthenext10charactersevenifnewfiledescriptoris
used
write(1,buff,10);
}
Programforfork()systemcall
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
intmain()
{
pid_tp;
printf("beforefork\n");
p=fork();
if(p==0)
{
printf("Iamchildhavingid%d\n",getpid());
printf("Myparent'sidis%d\n",getppid());
}
else{
printf("Mychild'sidis%d\n",p);
printf("Iamparenthavingid%d\n",getpid());
}
printf("Common\n");
}
Programforwait()systemcallwhichmakestheparentprocesswaitforthechildtofinish.
#include<unistd.h>
#include<sys/types.h>
#include<stdio.h>
#include<sys/wait.h>
intmain()
{
pid_tp;
printf("beforefork\n");
p=fork();
if(p==0)//child
{
printf("Iamchildhavingid%d\n",getpid());
printf("Myparent'sidis%d\n",getppid());
}
else//parent
{
wait(NULL);
printf("Mychild'sidis%d\n",p);
printf("Iamparenthavingid%d\n",getpid());
}
printf("Common\n");
}
Program2:Programtocreateanorphanprocess
#include<stdio.h
#include<unistd.h>
#include<sys/types.h>
intmain()
{
pid_tp;
p=fork();
if(p==0)
{
sleep(5);//childgoestosleepandinthemeantimeparentterminates
printf("IamchildhavingPID%d\n",getpid());
printf("MyparentPIDis%d\n",getppid());
}
else
{
printf("IamparenthavingPID%d\n",getpid());
printf("MychildPIDis%d\n",p);
}
}
//zombie.c
#include<stdio.h>
#include<unistd.h>
intmain()
{
pid_tt;
t=fork();
if(t==0)
{
printf("Childhavingid%d\n",getpid());
}
else
{
printf("Parenthavingid%d\n",getpid());
sleep(15);//Parentsleeps.Runthepscommandduringthistime
}
}
//execl.c
#include<stdio.h>
#include<unistd.h>
intmain()
{
printf("Beforeexecl\n");
execl("/bin/ps","ps","-a",NULL);//
printf("Afterexeclp\n");
}
//threads
#include<pthread.h>
intpthread_create(pthread_t*thread,constpthread_attr_t*attr,void*(*start_routine)(void*),
voidarg);
Program 1:Program tocreatethreadsinlinux.Threadprints0-4whilethemainprocess
prints20-24
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>
void*thread_function(void*arg);
inti,j;
intmain(){
pthread_ta_thread; //threaddeclaration
pthread_create(&a_thread,NULL,thread_function,NULL);
//threadiscreated
pthread_join(a_thread,NULL);//processwaitsforthreadtofinish.//Commentthislineto
seethedifference
printf("InsideMainProgram\n");
for(j=20;j<25;j++)
{
printf("%d\n",j);
sleep(1);
}
}
void*thread_function(void*arg){
//theworktobedonebythethreadisdefinedinthisfunction
printf("InsideThread\n");
for(i=0;i<5;i++)
{
printf("%d\n",i);
sleep(1);
}
}
Program 2:Program tocreateathread.Thethreadprintsnumbersfrom zeroton,where
valueofnispassedfromthemainprocesstothethread.Themainprocessalsowaitsforthe
threadtofinishfirstandthenprintsfrom20-24.
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>
#include<string.h>
void*thread_function(void*arg);
inti,n,j;
intmain(){
char*m="5";
pthread_ta_thread; //threaddeclaration
void*result;
pthread_create(&a_thread,NULL,thread_function,m);//threadiscreated
pthread_join(a_thread,&result);
printf("Threadjoined\n");
for(j=20;j<25;j++)
{
printf("%d\n",j);
sleep(1);
}
printf("threadreturned%s\n",(char*)result);
}
void*thread_function(void*arg){
intsum=0;
n=atoi(arg);
for(i=0;i<n;i++)
{
printf("%d\n",i);
sleep(1);
}
pthread_exit("Done");//Threadreturns"Done"
}
Program 3:Program tocreateathread.Thethreadispassedmorethanoneinputfrom the
mainprocess.Forpassingmultipleinputsweneedtocreatestructureandincludeallthe
variablesthataretobepassedinthisstructure.
#include<stdio.h
#include<pthread.h>
structarg_struct{ //structurewhichcontainsmultiplevariablesthataretopassedasinput
tothethread
intarg1;
intarg2;
};
void*arguments(void*arguments)
{
structarg_struct*args=arguments;
printf("%d\n",args->arg1);
printf("%d\n",args->arg2);
pthread_exit(NULL);
}
intmain()
{
pthread_tt;
structarg_structargs;
args.arg1=5;
args.arg2=7;
pthread_create(&t,NULL,arguments,&args);
//structurepassedas4thargument
pthread_join(t,NULL);/*Waituntilthreadisfinished*/
}
//deadlock
#include<stdio.h>
#include<pthread.h>
#include<unistd.h>
void*function1();
void*function2();
pthread_mutex_tfirst_mutex;//mutexlock
pthread_mutex_tsecond_mutex;
intmain(){
pthread_mutex_init(&first_mutex,NULL);//initializethelock
pthread_mutex_init(&second_mutex,NULL);
pthread_tone,two;
pthread_create(&one,NULL,function1,NULL);//createthread
pthread_create(&two,NULL,function2,NULL);
pthread_join(one,NULL);
pthread_join(two,NULL);
printf("Threadjoined\n");
}
void*function1(){
pthread_mutex_lock(&first_mutex);//toacquiretheresource/mutexlock
printf("ThreadONEacquiredfirst_mutex\n");
sleep(1);
pthread_mutex_lock(&second_mutex);
printf("ThreadONEacquiredsecond_mutex\n");
pthread_mutex_unlock(&second_mutex);//toreleasetheresource
printf("ThreadONEreleasedsecond_mutex\n");
pthread_mutex_unlock(&first_mutex);
printf("ThreadONEreleasedfirst_mutex\n");
}
void*function2(){
pthread_mutex_lock(&second_mutex);
printf("ThreadTWOacquiredsecond_mutex\n");
sleep(1);
pthread_mutex_lock(&first_mutex);
printf("ThreadTWOacquiredfirst_mutex\n");
pthread_mutex_unlock(&first_mutex);
printf("ThreadTWOreleasedfirst_mutex\n");
pthread_mutex_unlock(&second_mutex);
printf("ThreadTWOreleasedsecond_mutex\n");
}
//racecondition
#include<pthread.h>
#include<stdio.h>
#include<unistd.h>
void*fun1();
void*fun2();
intshared=1;//sharedvariable
intmain()
{
pthread_tthread1,thread2;
pthread_create(&thread1,NULL,fun1,NULL);
pthread_create(&thread2,NULL,fun2,NULL);
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
printf("Finalvalueofsharedis%d\n",shared);//printsthelastupdatedvalueofshared
variable
}
void*fun1()
{
intx;
x=shared;//threadonereadsvalueofsharedvariable
printf("Thread1readsthevalueofsharedvariableas%d\n",x);
x++;//threadoneincrementsitsvalue
printf("LocalupdationbyThread1:%d\n",x);
sleep(1);//threadoneispreemptedbythread2
shared=x;//threadoneupdatesthevalueofsharedvariable
printf("ValueofsharedvariableupdatedbyThread1is:%d\n",shared);
}
void*fun2()
{
inty;
y=shared;//threadtworeadsvalueofsharedvariable
printf("Thread2readsthevalueas%d\n",y);
y--;//threadtwoincrementsitsvalue
printf("LocalupdationbyThread2:%d\n",y);
sleep(1);//threadtwoispreemptedbythread1
shared=y;//threadoneupdatesthevalueofsharedvariable
printf("ValueofsharedvariableupdatedbyThread2is:%d\n",shared);
}
//nodeadlock&racecondition
#include<pthread.h>
#include<stdio.h>
#include<unistd.h>
void*fun1();
void*fun2();
intshared=1;//sharedvariable
pthread_mutex_tl;//mutexlock
intmain()
{
pthread_mutex_init(&l,NULL);//initializingmutexlocks
pthread_tthread1,thread2;
pthread_create(&thread1,NULL,fun1,NULL);
pthread_create(&thread2,NULL,fun2,NULL);
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
printf("Finalvalueofsharedis%d\n",shared);//printsthelastupdatedvalueofshared
variable
}
void*fun1()
{
intx;
printf("Thread1tryingtoacquirelock\n");
pthread_mutex_lock(&l);//threadoneacquiresthelock.Now thread2willnotbeableto
acquirethelock//untilitisunlockedbythread1
printf("Thread1acquiredlock\n");
x=shared;//threadonereadsvalueofsharedvariable
printf("Thread1readsthevalueofsharedvariableas%d\n",x);
x++;//threadoneincrementsitsvalue
printf("LocalupdationbyThread1:%d\n",x);
sleep(1);//threadoneispre
shared=x;//threadoneupdatesthevalueofsharedvariable
printf("ValueofsharedvariableupdatedbyThread1is:%d\n",shared);
pthread_mutex_unlock(&l);
printf("Thread1releasedthelock\n");
}
void*fun2()
{
inty;
printf("Thread2tryingtoacquirelock\n");
pthread_mutex_lock(&l);
printf("Thread2acquiredlock\n");
y=shared;//threadtworeadsvalueofsharedvariable
printf("Thread2readsthevalueas%d\n",y);
y--;//threadtwoincrementsitsvalue
printf("LocalupdationbyThread2:%d\n",y);
sleep(1);//threadtwoispreemptedbythread1
shared=y;//threadoneupdatesthevalueofsharedvariable
printf("ValueofsharedvariableupdatedbyThread2is:%d\n",shared);
pthread_mutex_unlock(&l);
printf("Thread2releasedthelock\n");
}
//semaphore
#include<pthread.h>
#include<stdio.h>
#include<semaphore.h>
#include<unistd.h>
void*fun1();
void*fun2();
intshared=1;//sharedvariable
sem_ts;//semaphorevariable
intmain()
{
sem_init(&s,0,1);//initializesemaphorevariable-1stargumentisaddressofvariable,2ndis
numberofprocessessharingsemaphore,3rdargumentistheinitialvalueofsemaphore
variable
pthread_tthread1,thread2;
pthread_create(&thread1,NULL,fun1,NULL);
pthread_create(&thread2,NULL,fun2,NULL);
pthread_join(thread1,NULL);
pthread_join(thread2,NULL);
printf("Finalvalueofsharedis%d\n",shared);//printsthelastupdatedvalueofshared
variable
}
void*fun1()
{
intx;
sem_wait(&s);//executeswaitoperationons
x=shared;//thread1readsvalueofsharedvariable
printf("Thread1readsthevalueas%d\n",x);
x++;//thread1incrementsitsvalue
printf("LocalupdationbyThread1:%d\n",x);
sleep(1);//thread1ispreemptedbythread2
shared=x;//threadoneupdatesthevalueo
printf("ValueofsharedvariableupdatedbyThread1is:%d\n",shared);
sem_post(&s);
}
void*fun2()
{
inty;
sem_wait(&s);
y=shared;//thread2readsvalueofsharedvariable
printf("Thread2readsthevalueas%d\n",y);
y--;//thread2incrementsitsvalue
printf("LocalupdationbyThread2:%d\n",y);
sleep(1);//thread2ispreemptedbythread1
shared=y;//thread2updatesthevalueofsharedvariable
printf("ValueofsharedvariableupdatedbyThread2is:%d\n",shared);
sem_post(&s);
}
//diningphilosopherproblem
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>
sem_tchopstick[5];
void*philos(void*);
voideat(int);
intmain()
{
inti,n[5];
pthread_tT[5];
for(i=0;i<5;i++)
sem_init(&chopstick[i],0,1);
for(i=0;i<5;i++){
n[i]=i;
pthread_create(&T[i],NULL,philos,(void*)&n[i]);
}
for(i=0;i<5;i++)
pthread_join(T[i],NULL);
}
void*philos(void*n)
{
intph=*(int*)n;
printf("Philosopher%dwantstoeat\n",ph);
printf("Philosopher%dtriestopickleftchopstick\n",ph);
sem_wait(&chopstick[ph]);
printf("Philosopher%dpickstheleftchopstick\n",ph);
printf("Philosopher%dtriestopicktherightchopstick\n",ph);
sem_wait(&chopstick[(ph+1)%5]);
printf("Philosopher%dpickstherightchopstick\n",ph);
eat(ph);
sleep(2);
printf("Philosopher%dhasfinishedeating\n",ph);
sem_post(&chopstick[(ph+1)%5]);
printf("Philosopher%dleavestherightchopstick\n",ph);
sem_post(&chopstick[ph]);
printf("Philosopher%dleavestheleftchopstick\n",ph);
}
voideat(intph)
{
printf("Philosopher%dbeginstoeat\n",ph);
}
//IPC-interprocesscommunication
#include<stdio.h>
FILE*popen(constchar*command,constchar*type)
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
intmain()
{
FILE*rd;
charbuffer[50];
sprintf(buffer,"namefirst");
rd=popen("wc-c","w");//wc-c->istheprocesswhichcountsthenumberofcharacters
passed.2ndparameteris"w"whichmeanspipeisopenedinwritingmode
fwrite(buffer,sizeof(char),strlen(buffer),rd);//towritethedataintothepipe
pclose(rd);
}
Programtoreadfromapipei.e.toreceivedatafromanotherprocess
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
intmain()
{
FILE*rd;
charbuffer[50];
rd=popen("ls","r");//pipeopenedinreadingmode
fread(buffer,1,40,rd);//willreadonly50characters
printf("%s\n",buffer);
pclose(rd);
}
ProgramforIPCusingnamedpipes(mkfifo())
#include<sys/types.h>
#include<sys/stat.h>
intmkfifo(constchar*pathname,mode_tmode);
Program1:Creatingfifo/namedpipe
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
intmain()
{
intres;
res=mkfifo("fifo1",0777);//createsanamedpipewiththenamefifo1
printf("namedpipecreated\n");
}
Program2:Writingtoafifo/namedpipe(2.c)
#include<unistd.h>
#include<stdio.h>
#include<fcntl.h>
intmain()
{
intres,n;
res=open("fifo1",O_WRONLY);
write(res,"Message",7);
printf("SenderProcess%dsentthedata\n",getpid());
}
Program3:Readingfromthenamedpipe(3.c)
#include<unistd.h>
#include<stdio.h>
#include<fcntl.h>
intmain()
{
intres,n;
charbuffer[100];
res=open("fifo1",O_RDONLY);
n=read(res,buffer,100);
printf("Readerprocess%dstarted\n",getpid());
printf("Datareceivedbyreceiver%dis:%s\n",getpid(),buffer);
}
Thisprogram createsasharedmemorysegment,attachesitselftoitandthenwritessome
contentintothesharedmemorysegment.
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
intmain()
{
inti;
void*shared_memory;
charbuff[100];
intshmid;
shmid=shmget((key_t)2345,1024,0666|IPC_CREAT);//createssharedmemorysegmentwith
key2345,havingsize1024bytes.IPC_CREATisusedtocreatethesharedsegmentifitdoes
notexist.0666arethepermisionsonthesharedsegment
printf("Keyofsharedmemoryis%d\n",shmid);
shared_memory=shmat(shmid,NULL,0);//processattachedtosharedmemorysegment
printf("Processattached at%p\n",shared_memory);//thisprintstheaddresswherethe
segmentisattachedwiththisprocess
printf("Entersomedatatowritetosharedmemory\n");
read(0,buff,100);//getsomeinputfromuser
strcpy(shared_memory,buff);//datawrittentosharedmemory
printf("Youwrote:%s\n",(char*)shared_memory);
}
Thisprogram attachesitselftothesharedmemorysegmentcreatedinProgram 1.Finally,it
readsthecontentofthesharedmemory
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/shm.h>
#include<string.h>
intmain()
{
inti;
void*shared_memory;
charbuff[100];
intshmid;
shmid=shmget((key_t)2345,1024,0666);
printf("Keyofsharedmemoryis%d\n",shmid);
shared_memory=shmat(shmid,NULL,0);//processattachedtosharedmemorysegment
printf("Processattachedat%p\n",shared_memory);
printf("Datareadfromsharedmemoryis:%s\n",(char*)shared_memory);
}
ProgramforIPCusingmessagequeues
intmsgget(key_tkey,intmsgflg);
intmsgsnd(intmsqid,constvoid*msg_ptr,size_tmsg_sz,intmsgflg);
intmsgrcv(intmsqid,void*msg_ptr,size_tmsg_sz,longintmsgtype,intmsgflg);
intmsgctl(intmsqid,intcommand,structmsqid_ds*buf);
CommandDescription
IPC_STATSetsthedatainthemsqid_dsstructuretoreflectthevaluesassociatedwiththe
messagequeue.
IPC_SETIftheprocesshaspermissiontodoso,thissetsthevaluesassociatedwiththe
messagequeuetothoseprovidedinthemsqid_dsdatastructure.
IPC_RMIDDeletesthemessagequeue.
Program1:ProgramforIPCusingMessageQueuesTosenddatatoamessagequeue
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
#defineMAX_TEXT512//maximumlengthofthemessagethatcanbesentallowed
structmy_msg{
longintmsg_type;
charsome_text[MAX_TEXT];
};
intmain()
{
intrunning=1;
intmsgid;
structmy_msgsome_data;
charbuffer[50];//arraytostoreuserinput
msgid=msgget((key_t)14534,0666|IPC_CREAT);
if(msgid==-1)//-1meansthemessagequeueisnotcreated
{
printf("Errorincreatingqueue\n");
exit(0);
}
while(running)
{
printf("Entersometext:\n");
fgets(buffer,50,stdin);
some_data.msg_type=1;
strcpy(some_data.some_text,buffer);
if(msgsnd(msgid,(void*)&some_d
MAX_TEXT,0)==-1)//msgsndreturns-1ifthemessageisnotsent
{
printf("Msgnotsent\n");
}
if(strncmp(buffer,"end",3)==0)
{
running=0;
}
}
}
Program2:ProgramforIPCusingMessageQueuesToreceive/readmessagefromtheabove
-createdmessagequeue
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/msg.h>
structmy_msg{
longintmsg_type;
charsome_text[BUFSIZ];
};
intmain()
{
intrunning=1;
intmsgid;
structmy_msgsome_data;
longintmsg_to_rec=0;
msgid=msgget((key_t)12345,0666|IPC_CREAT);
while(running)
{
msgrcv(msgid,(void*)&some_data,BUFSIZ,msg_to_rec,0);
printf("Datareceived:%s\n",some_data.some_text);
if(strncmp(some_data.some_text,"end",3)==0)
{
running=0;
}
}
msgctl(msgid,IPC_RMID,0);
}